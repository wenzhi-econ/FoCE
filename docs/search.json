[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dynamic Programming Basics",
    "section": "",
    "text": "Preface\nThis website stores my notes on solving simply dynamic programming problems in economics using Python. Theses are based on the course Foundation of Computational Economics, ANU, 2021.\nThe notes focus on the following three points: 1. Create a proper Python object to represent an economics model. 2. Conduct unit tests when developing model methods to solve the model. 3. Use type hinting to track down the calculation process, and minimize potential errors in each step.\nThe notes do not necessarily present the best numerical methods and solution methods to deal with these models. It is more programming-oriented, aiming to improve my Python skills to solve, simulate, and estimate an economics model.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01CakeEating.html",
    "href": "01CakeEating.html",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "",
    "text": "1.1 Problem Setup\nSuppose that we are presented with a cake of size \\(W_0\\) at time \\(0\\). At each period of time \\(t = 0, 1, \\ldots\\), you can eat some of the cake but must save the rest. Let \\(c_t\\) be your consumption in period \\(t\\), and let \\(u(c_t)\\) represent the flow of utility from this consumption. Here, we use \\(u(c) = \\log(c)\\), which is real valued, differentiable, strictly increasing, and strictly concave, and \\(\\lim_{c \\rightarrow 0^+} u^\\prime(c) = +\\infty\\). Therefore, the problem is\n\\[\n\\begin{aligned}\n    \\max_{\\{c_t\\}_{t=0}^{\\infty}} & \\sum_{t=0}^{\\infty} \\beta^t u(c_t) \\\\\n    \\text{s.t.   } & W_{t+1} = W_t - c_t, \\\\\n    & c_{t}\\geq 0,\\; W_{t+1} \\geq 0, \\; t = 0, 1, \\ldots; \\\\\n    \\text{given  } & W_0 &gt; 0.\n\\end{aligned}\n\\]\nThe Bellman equation associated with this problem is\n\\[\nV(W_t) = \\max_{0 \\leq c_t \\leq W_t} \\left\\{u(c_t) + \\beta V(\\underbrace{W_{t+1}}_{=W_t - c_t} )\\right\\}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "01CakeEating.html#problem-setup",
    "href": "01CakeEating.html#problem-setup",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "",
    "text": "1.1.1 Analytical Solution\nWe start with a guess that\n\\[\nV(W) = A + B \\log(W),\n\\]\nwhere \\(A\\) and \\(B\\) are coefficients to be determined. Given this conjecture, we can write the Bellman equation as\n\\[\nA+B \\log (W)=\\max _c\\left\\{\\log c+\\beta \\left(A+B \\log (W-c) \\right)\\right\\}.\n\\]\nThe FOC is\n\\[\n\\frac{1}{c}-\\frac{\\beta B}{W-c}=0 \\quad \\Rightarrow \\quad c=\\frac{W}{1+\\beta B},\\; W-c=\\frac{\\beta B W}{1+\\beta B}.\n\\]\nThen we have \\[\n\\begin{aligned}\nA+B \\log (W)= & \\log (W)+\\log \\frac{1}{1+\\beta B}+\\beta A+\\beta B \\log (W)+\\beta B \\log \\frac{\\beta B}{1+\\beta B} \\\\\n\\Rightarrow & \\left\\{\\\n\\begin{array}{ll}\n    & A=\\beta A+\\log \\frac{1}{1+\\beta B}+\\beta B \\log \\frac{\\beta B}{1+\\beta B} \\\\\n    & B=1+\\beta B\n\\end{array}\\right.\n\\end{aligned}\n\\]\nAfter some algebraic calculation, we can obtain the analytic solution to this simple cake-eating problem:\n\\[\n\\begin{aligned}\n& c^{\\star}(W)=(1-\\beta) W \\\\\n& V(W)=\\frac{\\log (W)}{1-\\beta}+\\frac{\\log (1-\\beta)}{1-\\beta}+\\frac{\\beta \\log (\\beta)}{(1-\\beta)^2}\n\\end{aligned}\n\\]\n\n\n1.1.2 A Python Class to Represent the Problem\nFirst, there are two model parameters, \\(\\beta\\) and \\(W_0\\). However, these two economics parameters are not enough to represent this problem in a computer, we need other numerical parameters to solve the problem, which are all set to be optional arguments when initializing an instance.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import interpolate\nfrom cycler import cycler\n\n# && type hinting relevant variables\n1from typing import Annotated, Literal, TypeVar, Union\nimport numpy.typing as npt\n\nDType = TypeVar(\"DType\", bound=np.generic)\nArrayNxN = Annotated[npt.NDArray[DType], Literal[\"ngridw\", \"ngridw\"]]\nArrayNxNc = Annotated[npt.NDArray[DType], Literal[\"ngridw\", \"ngridc\"]]\nArrayN = Annotated[npt.NDArray[DType], Literal[\"ngridw\"]]\nCollection_float = Union[ArrayN[np.float64], ArrayNxN[np.float64], np.float64]\nNumerical_pars = Union[dict[str, float], dict[str, int]]\n\n\nclass CakeEating:\n    \"\"\"\n    This class solves the cake-eating problems using different numerical\n    methods.\n\n    Through this script, I hope to be more familiar with creating a\n    Python class to represent an economics model, and to be more\n    familiar with NumPy type hinting to track the calculation process,\n    and to perform unit tests when developing codes.\n    \"\"\"\n\n    def __init__(\n        self,\n        beta: float = 0.9,\n        w0: float = 10,\n2        **kwargs: Numerical_pars,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an object instance with model parameters, and\n        possibly numerical parameters.\n        \"\"\"\n\n        # -? model parameters\n        self.beta = beta\n        self.w0 = w0\n\n        # -? numerical parameters\n3        self.kwargs = kwargs\n        if \"ngridw\" in kwargs:\n            assert isinstance(\n                kwargs[\"ngridw\"], int\n            ), \"ngridw should be an integer!\"\n            self.ngridw = kwargs[\"ngridw\"]\n        else:\n            self.ngridw = 100\n\n        if \"ngridc\" in kwargs:\n            assert isinstance(\n                kwargs[\"ngridc\"], int\n            ), \"ngridc should be an integer!\"\n            self.ngridc = kwargs[\"ngridc\"]\n        else:\n            self.ngridc = 200\n\n        if \"adapted_grid_c\" in kwargs:\n            assert isinstance(\n                kwargs[\"adapted_grid_c\"], bool\n            ), \"adapted_grid_c should be a boolen\"\n            self.adapted_grid_c = kwargs[\"adapted_grid_c\"]\n        else:\n            self.adapted_grid_c = True\n\n        if \"max_iter\" in kwargs:\n            assert isinstance(\n                kwargs[\"max_iter\"], int\n            ), \"max_iter should be an integer!\"\n            self.max_iter = kwargs[\"max_iter\"]\n        else:\n            self.max_iter = 1000\n\n        if \"relative_error\" in kwargs:\n            assert isinstance(\n                kwargs[\"relative_error\"], bool\n            ), \"relative_error should be a boolen\"\n            self.relative_error = kwargs[\"relative_error\"]\n        else:\n            self.relative_error = False\n\n        if \"c_min\" in kwargs:\n            assert isinstance(kwargs[\"c_min\"], float)\n            self.c_min = kwargs[\"c_min\"]\n        else:\n            self.c_min = 1e-10\n\n        if \"tol\" in kwargs:\n            assert isinstance(kwargs[\"tol\"], float)\n            self.tol = kwargs[\"tol\"]\n        else:\n            self.tol = 1e-4\n\n    def __repr__(self) -&gt; str:\n        numerical_parameters = [str((par, self.kwargs[par])) for par in self.kwargs]\n        return (\n            f\"A simple cake-eating problem with beta = {self.beta:.2f}, \"\n            f\"and initial wealth W_0 = {self.w0:.3f}.\\n\"\n            f\"Other non-default numerical parameters are set to \"\n            f\"{', ' .join(numerical_parameters)}.\"\n        )\n\n\n1\n\nI use type hinting for the model parameters, as they are often soft requirements, and we are very unlikely to pass wrong types to these arguments.\n\n2\n\nI collect the numerical parameters as optional arguments, as these parameters depend on which numerical methods we are using, so they can vary case by case. Essentially, an economics model is only represented by the model parameters.\n\n3\n\nFor the numerical parameters, I use strong assert statements to check the passing numerical parameters, since this is more likely to be sources of mistakes.\n\n\n\n\n\n\n1.1.3 Unit Tests\nHow can we make sure that our class works just as our expectation, even though only the constructor has been coded up? One important approach is to perform unit tests, which specifically test this unit of codes.\nIn principle, we can manually check if our constructor gets the same results as our expectations. For example,\n\n\nCode\nmodel1 = CakeEating()\nprint(model1)\nmodel1.beta\nmodel1.w0\nmodel1.ngridw\nmodel1.c_min\nmodel1.tol\n\nmodel4 = CakeEating(beta = 0.66, ngridw=1000, c_min=1e-5)\nmodel4.beta\nmodel4.w0\nmodel4.ngridw\nmodel4.c_min\nmodel4.tol\n\n# model_wrongNtype = CakeEating(ngridw=10.0) \n#     AssertionError: ngridw should be an integer!\n\n\nExecuting the final line will throw out an error message, which is exactly what we want – a strict type checking for numerical parameters. However, a better way to perform these tests is using certain testing framework, which can greatly reduce our burden.\n\n\ntest_CakeEating.py\n\n# | eval: false\n\n1import CakeEating as CE\n\nimport pytest\n\ndef test_init_model_pars():\n    model1 = CE.CakeEating()\n    assert model1.beta == 0.90\n2    assert model1.w0 == pytest.approx(100.0)\n\n    model2 = CE.CakeEating(beta=0.66)\n    assert model2.beta == pytest.approx(0.66)\n\n\ndef test_init_numerical_types():\n3    model3 = CE.CakeEating(ngridw=99.0)\n    assert model3.ngridw == 99\n\n# def test_init_numerical_types_elegant():\n4#     with pytest.raises(AssertionError):\n#         model3 = CE.CakeEating(ngridw=99.0)\n#         assert model3.ngridw == 99\n\ndef test_init_numerical_pars():\n    model3 = CE.CakeEating(ngridw=1000, tol=1e-9)\n    assert model3.ngridw == 1000\n    assert model3.c_min == 1e-10\n    assert model3.tol == 1e-9\n\n5pytest.main()\n\n\n1\n\nIf we are separating the model script and the test script into two files, then an extra importation step is needed.\n\n2\n\npytest.approx() is used to compare two floats.\n\n3\n\nWe are expecting an error message will be thrown out.\n\n4\n\nIf we run this alternative test with exception capturing, then we will actually pass the test.\n\n5\n\nRight now, we cannot run this in IPython. Therefore, after saving this file, we need to run the following command in the command line: pytest \"test_CakeEating.py\" to show the results.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "01CakeEating.html#on-the-grid-solution-method-discretize-only-w",
    "href": "01CakeEating.html#on-the-grid-solution-method-discretize-only-w",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "1.2 On-the-Grid Solution Method: Discretize only \\(W\\)",
    "text": "1.2 On-the-Grid Solution Method: Discretize only \\(W\\)\n\n1.2.1 Value Function Iteration: Interpolation is Necessary\nValue function iteration means that we start with an arbitrary guess \\(V_0(W)\\). At iteration \\(i = 1, 2, \\ldots\\), we compute\n\\[\n\\begin{aligned}\nV_i(W)=T\\left(V_{i-1}\\right)(W) & =\\max _{0 \\leq c \\leq W}\\left\\{u(c)+\\beta V_{i-1}(W-c)\\right\\} \\\\\nc_{i-1}(W) & =\\underset{0 \\leq c \\leq W}{\\arg \\max }\\left\\{u(c)+\\beta V_{i-1}(W-c)\\right\\}\n\\end{aligned}.\n\\]\nTo put this idea into practice, we first need dto construct a grid of cake-sizes \\(\\overrightarrow{W} \\in \\mathcal{W} := \\{0, \\ldots, \\overline{W}\\}\\), and then calculate the following maximization problem in iteration \\(i\\):\n\\[\nV_i(\\overrightarrow{W})=\\max _{0 \\leq c \\leq \\overrightarrow{W}}\\left\\{u(c)+\\beta V_{i-1}(\\overrightarrow{W}-c)\\right\\}.\n\\]\nHowever, one important complication is that we need to evaluate \\(V_{i-1}\\) off-the-grids, that is, there is no guarantee that \\(\\overrightarrow{W}-c \\in \\mathcal{W}\\). Therefore, we need to exploit some interpolation or function approximation techniques.\n\n\n1.2.2 Assume \\(c\\) Can ONLY Take Gaps between Gridpoints as Values\nWe can re-organize the Bellman equation as\n\\[\nV_i(\\overrightarrow{W})=\\max _{0 \\leq \\overrightarrow{W}^{\\prime} \\leq \\overrightarrow{W}}\\left\\{u\\left(\\overrightarrow{W}-\\overrightarrow{W}^{\\prime}\\right)+\\beta V_{i-1}\\left(\\overrightarrow{W}^{\\prime}\\right)\\right\\}.\n\\]\nBy choosing \\(\\overrightarrow{W}, \\overrightarrow{W}^{\\prime} \\in \\mathcal{W}\\), the last-iteration value function \\(V_{i-1}\\) is always evaluated on the grid, thus avoiding interpolation. However, noting that this re-arrangement has strong numerical implications: since we require \\(\\overrightarrow{W}^{\\prime} \\in \\mathcal{W}\\), this implies that the consumption take only take discrete values that are gaps between gridpoints in the \\(\\mathcal{W}\\) grid.\n\n\n1.2.3 Coding up the On-the-Grid Solution\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import interpolate\nfrom cycler import cycler\n\n# && type hinting relevant variables\nfrom typing import Annotated, Literal, TypeVar, Union\nimport numpy.typing as npt\n\nDType = TypeVar(\"DType\", bound=np.generic)\n\nArrayNxN = Annotated[npt.NDArray[DType], Literal[\"ngridw\", \"ngridw\"]]\nArrayNxNc = Annotated[npt.NDArray[DType], Literal[\"ngridw\", \"ngridc\"]]\nArrayN = Annotated[npt.NDArray[DType], Literal[\"ngridw\"]]\nCollection_float = Union[ArrayN[np.float64], ArrayNxN[np.float64], np.float64]\nNumerical_pars = Union[dict[str, float], dict[str, int]]\n\n\nclass CakeEating:\n    \"\"\"\n    This class solves the cake-eating problems using different numerical\n    methods.\n\n    Through this script, I hope to be more familiar with creating a\n    Python class to represent an economics model, and to be more\n    familiar with NumPy type hinting to track the calculation process,\n    and to perform unit tests when developing codes.\n    \"\"\"\n\n    def __init__(\n        self,\n        beta: float = 0.9,\n        w0: float = 10,\n        **kwargs: Numerical_pars,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an object instance with model parameters, and\n        possibly numerical parameters.\n        \"\"\"\n\n        # -? model parameters\n        self.beta = beta\n        self.w0 = w0\n\n        # -? numerical parameters\n        self.kwargs = kwargs\n        if \"ngridw\" in kwargs:\n            assert isinstance(\n                kwargs[\"ngridw\"], int\n            ), \"ngridw should be an integer!\"\n            self.ngridw = kwargs[\"ngridw\"]\n        else:\n            self.ngridw = 100\n\n        if \"ngridc\" in kwargs:\n            assert isinstance(\n                kwargs[\"ngridc\"], int\n            ), \"ngridc should be an integer!\"\n            self.ngridc = kwargs[\"ngridc\"]\n        else:\n            self.ngridc = 200\n\n        if \"adapted_grid_c\" in kwargs:\n            assert isinstance(\n                kwargs[\"adapted_grid_c\"], bool\n            ), \"adapted_grid_c should be a boolen\"\n            self.adapted_grid_c = kwargs[\"adapted_grid_c\"]\n        else:\n            self.adapted_grid_c = True\n\n        if \"max_iter\" in kwargs:\n            assert isinstance(\n                kwargs[\"max_iter\"], int\n            ), \"max_iter should be an integer!\"\n            self.max_iter = kwargs[\"max_iter\"]\n        else:\n            self.max_iter = 1000\n\n        if \"relative_error\" in kwargs:\n            assert isinstance(\n                kwargs[\"relative_error\"], bool\n            ), \"relative_error should be a boolen\"\n            self.relative_error = kwargs[\"relative_error\"]\n        else:\n            self.relative_error = False\n\n        if \"c_min\" in kwargs:\n            assert isinstance(kwargs[\"c_min\"], float)\n            self.c_min = kwargs[\"c_min\"]\n        else:\n            self.c_min = 1e-10\n\n        if \"tol\" in kwargs:\n            assert isinstance(kwargs[\"tol\"], float)\n            self.tol = kwargs[\"tol\"]\n        else:\n            self.tol = 1e-4\n\n    def __repr__(self) -&gt; str:\n        numerical_parameters = [str((par, self.kwargs[par])) for par in self.kwargs]\n        return (\n            f\"A simple cake-eating problem with beta = {self.beta:.2f}, \"\n            f\"and initial wealth W_0 = {self.w0:.3f}.\\n\"\n            f\"Other non-default numerical parameters are set to \"\n            f\"{', ' .join(numerical_parameters)}.\"\n        )\n\n1    @property\n    def grid_w(self) -&gt; ArrayN[np.float64]:\n        return np.linspace(\n            start=self.c_min, stop=self.w0, num=self.ngridw, endpoint=True\n        )\n\n    def utility(self, c: Collection_float):\n        return np.log(c)\n\n    def bellman_ongrid(self, V0: ArrayN[np.float64]):\n        \"\"\"\n        Given last-iteration value function, this method calculates\n        next-iteration value function using on-the-grid solution method.\n        \"\"\"\n        #!! step 1: check the shape of last-iteration value function\n        assert V0.shape == (self.ngridw,)\n\n        #!! step 2: construct a consumption array, where\n        #!! arr_c[i, j] == self.grid_w[i] - self.grid_w[j]\n2        arr_w_prime: ArrayNxN\n        arr_w: ArrayNxN\n        arr_w, arr_w_prime = np.meshgrid(\n3            self.grid_w, self.grid_w, indexing=\"ij\"\n        )\n\n        arr_c: ArrayNxN = arr_w - arr_w_prime\n        arr_c[arr_c &lt; 0] = np.nan\n        arr_c[arr_c == 0] = self.c_min\n\n        #!! step 3: construct the next-iteration value function array\n        #!! arr_value_prime[i,j]\n        #!! = log(self.grid_w[i] - self.grid_w[j]) + beta * V0[j]\n4        arr_V0: ArrayNxN\n        _, arr_V0 = np.meshgrid(V0, V0, indexing=\"ij\")\n        arr_value_prime = self.utility(arr_c) + self.beta * arr_V0\n\n        #!! step 4: get the next-iteration value function\n        #!! maximization over j, i.e., across columns\n        V_prime = np.nanmax(arr_value_prime, axis=1)\n\n        #!! step 4: get the consumption function\n        c_index = list(np.nanargmax(arr_value_prime, axis=1))\n        c = arr_c[list(range(self.ngridw)), c_index]\n\n        return V_prime, c\n\n    def solution_ongrid(self, callback=None):\n        \"\"\"\n        This method solves the cake eating problem using on-the-grid method.\n        \"\"\"\n        V0 = np.log(self.grid_w)\n\n        for iter in range(self.max_iter):\n5            # print(f\"Iteration: {iter+1}\\n\")\n            V1, c = self.bellman_ongrid(V0)\n            if callback is not None:\n                callback(iter, self.grid_w, V1, c)\n            if self.relative_error:\n                if np.all(np.abs(V1 - V0) / np.abs(V0) &lt; self.tol):\n                    break\n            else:\n                if np.all(abs(V1 - V0) &lt; self.tol):\n                    print(f\"Final iteration: {iter:3d}\")\n                    break\n            V0 = V1\n        else:\n            raise RuntimeError(\n                f\"Failed to converge in {self.max_iter} iterations.\"\n            )\n        return V1, c\n\n\n1\n\nThe \\(w\\) grid is a property without a setter, so that we will never change the wealth grid by assignment statements like model.grid_w = np.linsapce(1, 2, 10).\n\n2\n\nHere, I use type hinting for the results returned by the np.meshgrid() function. When developping the method for the first time, it is much better if we use assert statements – not only on the shapes of these two arrays, but possibly on their properties (e.g., each row of arr_w has the same entries, while each column of arr_w_prime has the same entries).\n\n3\n\nThe use of np.meshgrid() in dynamic programming.\n\n4\n\nSimilarly, we can use assert statements here.\n\n5\n\nIt is always better to indicate the program is at which iteration. Otherwise, there is no sign of program executions. However, here, to make output clearer, I will comment out this line.\n\n\n\n\n\n\n1.2.4 Testing the Numerical Solutions\nFirst, I will present the convergence for an example cate eating problem with \\(\\beta = 0.9\\), and \\(w_0 = 100\\). Relevant numerical parameters are set to ngridw = 1000, tol=1e-6, relative_error=True, max_iter = 1000, and c_min = 1e-10.\n\nmodel1 = CakeEating(\n    beta=0.9, w0=100, ngridw=1000, tol=1e-6, relative_error=True\n)\n\nTo plot the convergence process, I will first set up some figure options, and define a plotting function that will be called in each value function iteration process, which then allows me to visualize the convergence process in each iteration.\n\nplt.rcParams[\"axes.autolimit_mode\"] = \"round_numbers\"\nplt.rcParams[\"axes.xmargin\"] = 0\nplt.rcParams[\"axes.ymargin\"] = 0\nplt.rcParams[\"patch.force_edgecolor\"] = True\nplt.rcParams[\"axes.prop_cycle\"] = cycler(color=\"bgrcmyk\")\n\nfig1, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\nplt.grid(which=\"both\", color=\"0.65\", linestyle=\"-\")\n\nax1.set_title(\"Value function convergence with VFI\")\nax1.set_xlabel(\"Cake size, W\")\nax1.set_ylabel(\"Value function\")\n\nax2.set_title(\"Policy function convergence with VFI\")\nax2.set_xlabel(\"Cake size, W\")\nax2.set_ylabel(\"Policy function\")\n\ndef plot_value_convergence(iter, grid, v, c):\n    \"\"\"Callback function for DP solver\"\"\"\n    if iter &lt; 5 or iter % 10 == 0:\n        ax1.plot(grid[1:], v[1:], label=f\"iter = {iter+1:3d}\", linewidth=1)\n        ax2.plot(grid[1:], c[1:], label=f\"iter = {iter+1:3d}\", linewidth=1)\n\nmodel1_V, model1_c = model1.solution_ongrid(callback=plot_value_convergence)\nplt.legend(loc='upper left', bbox_to_anchor=(1.04, 1))\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\nSecond, I want to compare the numerical solution with the analytical solution. To do this, I will first define a function that calculate the analytical value function and consumption function for any model parameters. Then I will contrast the numerical solution with the analytical solution.\n\ndef analytical_solution(w, model):\n    beta = model.beta\n    value_func = (\n        np.log(w) / (1 - beta)\n        + np.log(1 - beta) / (1 - beta)\n        + beta * np.log(beta) / ((1 - beta) ** 2)\n    )\n    consump_func = (1 - beta) * w\n    return value_func, consump_func\n\nmodel1_V_true, model1_c_true = analytical_solution(model1.grid_w, model1)\n\n\n\nCode\nfigV, axV = plt.subplots(figsize=(8, 6))\naxV.set_title(\n    f\"Analytical versus numerical value function with {model1.ngridw = } using On-the-Grid method\"\n)\naxV.set_xlabel(\"Cake size, W\")\naxV.set_ylabel(\"Value function\")\n\naxV.plot(\n    model1.grid_w[1:],\n    model1_V[1:],\n    c=\"red\",\n    label=\"numerical VF\",\n)\naxV.plot(\n    model1.grid_w[1:],\n    model1_V_true[1:],\n    c=\"black\",\n    label=\"analytical VF\",\n)\naxV.legend()\nplt.ion()\nplt.show()\n\n\nfigC, axC = plt.subplots(figsize=(8, 6))\naxC.set_title(\n    f\"Analytical versus numerical policy function with {model1.ngridw = } using On-the-Grid method\"\n)\naxC.set_xlabel(\"Cake size, W\")\naxC.set_ylabel(\"Policy function\")\n\naxC.plot(\n    model1.grid_w[1:],\n    model1_c[1:],\n    c=\"red\",\n    label=\"numerical policy function\",\n)\naxC.plot(\n    model1.grid_w[1:],\n    model1_c_true[1:],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\naxC.legend()\nplt.ion()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "01CakeEating.html#discretization-solution-method-discretize-both-w-and-c",
    "href": "01CakeEating.html#discretization-solution-method-discretize-both-w-and-c",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "1.3 Discretization Solution Method: Discretize both \\(W\\) and \\(c\\)",
    "text": "1.3 Discretization Solution Method: Discretize both \\(W\\) and \\(c\\)\n\n1.3.1 Algorithm: Interpolation + Discretized \\(c\\)\nTo improve accuracy, we can go back to the original Bellman equation,\n\\[        \nV(W_t) = \\max_{0 \\leq c_t \\leq W_t} \\left\\{u(c_t) + \\beta V(\\underbrace{W_{t+1}}_{=W_t - c_t} )\\right\\},\n\\]\nand we treat \\(c_t\\) as our direct choice variable.\nThere are two choices if we wish to discretize the \\(c\\) grid, given a value of the state variable \\(W\\). Either we can use a fixed \\(c\\) grid, regardless of the current state variable value, or we can use an adapted \\(c\\) grid, considering the construct the grid with bounds \\([0,W]\\), so that the \\(c\\) grid is actually a function of the value of the state variable. In the following python codes, this choice is controlled by the adapted_c_grid attribute.\nAgain, there is no guarantee that \\(W_t - c_t\\) lies on the grid \\(\\overrightarrow{W}\\). To address this problem, we use a simple interpolation function scipy.interpolate.interp1d. I won’t take the credibility of the interpolation method seriously in this note, as the main focus is to develop good-quality and reader-friendly Python codes.\n\n\n1.3.2 Coding up the DIscretization Method\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import interpolate\nfrom cycler import cycler\n\n# && type hinting relevant variables\nfrom typing import Annotated, Literal, TypeVar, Union\nimport numpy.typing as npt\n\nDType = TypeVar(\"DType\", bound=np.generic)\n\nArrayNxN = Annotated[npt.NDArray[DType], Literal[\"ngridw\", \"ngridw\"]]\nArrayNxNc = Annotated[npt.NDArray[DType], Literal[\"ngridw\", \"ngridc\"]]\nArrayN = Annotated[npt.NDArray[DType], Literal[\"ngridw\"]]\nCollection_float = Union[ArrayN[np.float64], ArrayNxN[np.float64], np.float64]\nNumerical_pars = Union[dict[str, float], dict[str, int]]\n\n\nclass CakeEating:\n    \"\"\"\n    This class solves the cake-eating problems using different numerical\n    methods.\n\n    Through this script, I hope to be more familiar with creating a\n    Python class to represent an economics model, and to be more\n    familiar with NumPy type hinting to track the calculation process,\n    and to perform unit tests when developing codes.\n    \"\"\"\n\n    def __init__(\n        self,\n        beta: float = 0.9,\n        w0: float = 10,\n        **kwargs: Numerical_pars,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an object instance with model parameters, and\n        possibly numerical parameters.\n        \"\"\"\n\n        # -? model parameters\n        self.beta = beta\n        self.w0 = w0\n\n        # -? numerical parameters\n        self.kwargs = kwargs\n        if \"ngridw\" in kwargs:\n            assert isinstance(\n                kwargs[\"ngridw\"], int\n            ), \"ngridw should be an integer!\"\n            self.ngridw = kwargs[\"ngridw\"]\n        else:\n            self.ngridw = 100\n\n        if \"ngridc\" in kwargs:\n            assert isinstance(\n                kwargs[\"ngridc\"], int\n            ), \"ngridc should be an integer!\"\n            self.ngridc = kwargs[\"ngridc\"]\n        else:\n            self.ngridc = 200\n\n        if \"adapted_grid_c\" in kwargs:\n            assert isinstance(\n                kwargs[\"adapted_grid_c\"], bool\n            ), \"adapted_grid_c should be a boolen\"\n            self.adapted_grid_c = kwargs[\"adapted_grid_c\"]\n        else:\n            self.adapted_grid_c = True\n\n        if \"max_iter\" in kwargs:\n            assert isinstance(\n                kwargs[\"max_iter\"], int\n            ), \"max_iter should be an integer!\"\n            self.max_iter = kwargs[\"max_iter\"]\n        else:\n            self.max_iter = 1000\n\n        if \"relative_error\" in kwargs:\n            assert isinstance(\n                kwargs[\"relative_error\"], bool\n            ), \"relative_error should be a boolen\"\n            self.relative_error = kwargs[\"relative_error\"]\n        else:\n            self.relative_error = False\n\n        if \"c_min\" in kwargs:\n            assert isinstance(kwargs[\"c_min\"], float)\n            self.c_min = kwargs[\"c_min\"]\n        else:\n            self.c_min = 1e-10\n\n        if \"tol\" in kwargs:\n            assert isinstance(kwargs[\"tol\"], float)\n            self.tol = kwargs[\"tol\"]\n        else:\n            self.tol = 1e-4\n\n    def __repr__(self) -&gt; str:\n        numerical_parameters = [\n            str((par, self.kwargs[par])) for par in self.kwargs\n        ]\n        return (\n            f\"A simple cake-eating problem with beta = {self.beta:.2f}, \"\n            f\"and initial wealth W_0 = {self.w0:.3f}.\\n\"\n            f\"Other non-default numerical parameters are set to \"\n            f\"{', ' .join(numerical_parameters)}.\"\n        )\n\n    @property\n    def grid_w(self) -&gt; ArrayN[np.float64]:\n        return np.linspace(\n            start=self.c_min, stop=self.w0, num=self.ngridw, endpoint=True\n        )\n\n    def utility(self, c: Collection_float):\n        return np.log(c)\n\n    def bellman_ongrid(self, V0: ArrayN[np.float64]):\n        \"\"\"\n        Given last-iteration value function, this method calculates\n        next-iteration value function using on-the-grid solution method.\n        \"\"\"\n        #!! step 1: check the shape of last-iteration value function\n        assert V0.shape == (self.ngridw,)\n\n        #!! step 2: construct a consumption array, where\n        #!! arr_c[i, j] == self.grid_w[i] - self.grid_w[j]\n        arr_w_prime: ArrayNxN\n        arr_w: ArrayNxN\n        arr_w, arr_w_prime = np.meshgrid(\n            self.grid_w, self.grid_w, indexing=\"ij\"\n        )\n\n        arr_c: ArrayNxN = arr_w - arr_w_prime\n        arr_c[arr_c &lt; 0] = np.nan\n        arr_c[arr_c == 0] = self.c_min\n\n        #!! step 3: construct the next-iteration value function array\n        #!! arr_value_prime[i,j]\n        #!! = log(self.grid_w[i] - self.grid_w[j]) + beta * V0[j]\n        arr_V0: ArrayNxN\n        _, arr_V0 = np.meshgrid(V0, V0, indexing=\"ij\")\n        arr_value_prime = self.utility(arr_c) + self.beta * arr_V0\n\n        #!! step 4: get the next-iteration value function\n        #!! maximization over j, i.e., across columns\n        V_prime = np.nanmax(arr_value_prime, axis=1)\n\n        #!! step 4: get the consumption function\n        c_index = list(np.nanargmax(arr_value_prime, axis=1))\n        c = arr_c[list(range(self.ngridw)), c_index]\n\n        return V_prime, c\n\n    def solution_ongrid(self, callback=None):\n        \"\"\"\n        This method solves the cake eating problem using on-the-grid method.\n        \"\"\"\n        V0 = np.log(self.grid_w)\n\n        for iter in range(self.max_iter):\n            print(f\"Iteration: {iter+1}\\n\")\n            V1, c = self.bellman_ongrid(V0)\n            if callback is not None:\n                callback(iter, self.grid_w, V1, c)\n            if self.relative_error:\n                if np.all(np.abs(V1 - V0) / np.abs(V0) &lt; self.tol):\n                    break\n            else:\n                if np.all(abs(V1 - V0) &lt; self.tol):\n                    break\n            V0 = V1\n        else:\n            raise RuntimeError(\n                f\"Failed to converge in {self.max_iter} iterations.\"\n            )\n        return V1, c\n\n    @property\n1    def arr_c(self) -&gt; ArrayNxNc:\n        \"\"\"\n        This method returns the consumption array.\n        arr_c[i, :] is the consumption grid when wealth level is self.grid_w[i].\n        \"\"\"\n        if self.adapted_grid_c:\n            arr_c = np.zeros(shape=(self.ngridw, self.ngridc))\n            for w_index in range(self.ngridw):\n                arr_c[w_index, :] = np.linspace(\n                    start=self.c_min, stop=self.grid_w[w_index], num=self.ngridc\n                )\n        else:\n            grid_c = np.linspace(\n                start=self.c_min, stop=self.w0, num=self.ngridc\n            )\n            _, arr_c = np.meshgrid(self.grid_w, grid_c, indexing=\"ij\")\n\n        assert arr_c.shape == (self.ngridw, self.ngridc)\n2        return arr_c\n\n    def bellman_discretization(self, V0: ArrayN[np.float64]):\n        assert V0.shape == (self.ngridw,)\n\n        #!! arr_w_prime[i, j] = arr_w[i, j] - self.arr_c[i, j]\n        #!! = grid_w[i] - self.arr_c[i, j]\n3        arr_w = ArrayNxNc[np.float64]\n        arr_w = np.tile(self.grid_w.reshape((self.ngridw, 1)), reps=self.ngridc)\n        arr_w_prime = arr_w - self.arr_c \n        arr_w_prime[arr_w_prime &lt; 0] = np.nan\n        arr_w_prime[arr_w_prime == 0] = self.c_min\n\n4        interp = interpolate.interp1d(\n            self.grid_w,\n            V0,\n            bounds_error=False,\n            fill_value=\"extrapolate\",\n        )\n\n        arr_V1 = self.utility(self.arr_c) + self.beta * interp(arr_w_prime)\n\n        V1 = np.nanmax(arr_V1, axis=1)\n        c_index = list(np.nanargmax(arr_V1, axis=1))\n        c = self.arr_c[list(range(self.ngridw)), c_index].ravel()\n\n        return V1, c\n\n    def solution_discretization(self, callback=None):\n        \"\"\"\n        This method solves the cake eating problem using on-the-grid method.\n        \"\"\"\n        V0 = np.log(self.grid_w)\n\n        for iter in range(self.max_iter):\n            # print(f\"Iteration: {iter+1}\\n\")\n            V1, c = self.bellman_discretization(V0)\n            if callback is not None:\n                callback(iter, self.grid_w, V1, c)\n            if self.relative_error:\n                if np.all(np.abs(V1 - V0) / np.abs(V0) &lt; self.tol):\n                    print(f\"Final iteration: {iter+1:3d}\")\n                    break\n            else:\n                if np.all(abs(V1 - V0) &lt; self.tol):\n                    break\n            V0 = V1\n        else:\n            raise RuntimeError(\n                f\"Failed to converge in {self.max_iter} iterations.\"\n            )\n        return V1, c\n\n\n1\n\nWhen performing the discretization method, we need another consumption grid. However, since we may want an adapted consumption grid, that is, we may want the grid to vary by different wealth level, we will need a consumption array, where the row index indicates the wealth grid index. For each row, there is a consumption grid, which is the same across rows if adapted_grid_c==False, and different if adapted_grid_c==True.\n\n2\n\nSimilarly, after developping this attribute, we need to test it, using the unit test framework, or simply printing out the resulting consumption arrays.\n\n3\n\nNow, the shape of the consumption array is (ngridw, ngridc), we also need the wealth array to be of the same shape, and we are implementing this using the np.tile() function.\n\n4\n\nInterpolation is needed in the discretization solution method.\n\n\n\n\n\n\n1.3.3 Testing the Numerical Solutions\nFirst, I will use a relatively fine grids on both wealth and consumption, with the same model parameters as model1.\n\n\nCode\nmodel2 = CakeEating(\n    beta=0.9, \n    w0=100, \n    ngridw=1000, \n    ngridc=1000,\n    adapted_grid_c=True,\n    tol=1e-6, \n    relative_error=True\n)\n\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n# -? test for convergence\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n\nplt.rcParams[\"axes.autolimit_mode\"] = \"round_numbers\"\nplt.rcParams[\"axes.xmargin\"] = 0\nplt.rcParams[\"axes.ymargin\"] = 0\nplt.rcParams[\"patch.force_edgecolor\"] = True\nplt.rcParams[\"axes.prop_cycle\"] = cycler(color=\"bgrcmyk\")\n\nfig1, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\nplt.grid(which=\"both\", color=\"0.65\", linestyle=\"-\")\n\nax1.set_title(\"Value function convergence with VFI\")\nax1.set_xlabel(\"Cake size, W\")\nax1.set_ylabel(\"Value function\")\n\nax2.set_title(\"Policy function convergence with VFI\")\nax2.set_xlabel(\"Cake size, W\")\nax2.set_ylabel(\"Policy function\")\n\n\ndef plot_value_convergence(iter, grid, v, c):\n    \"\"\"Callback function for DP solver\"\"\"\n    if iter &lt; 5 or iter % 10 == 0:\n        ax1.plot(grid[1:], v[1:], label=f\"iter = {iter+1:3d}\", linewidth=1)\n        ax2.plot(grid[1:], c[1:], label=f\"iter = {iter+1:3d}\", linewidth=1)\n\n\nmodel2_V, model2_c = model2.solution_discretization(callback=plot_value_convergence)\nplt.legend(loc=\"upper left\", bbox_to_anchor=(1.04, 1))\nplt.ion()\nplt.show()\n\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n# -? compare with numerical solutions\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n\ndef analytical_solution(w, model):\n    beta = model.beta\n    value_func = (\n        np.log(w) / (1 - beta)\n        + np.log(1 - beta) / (1 - beta)\n        + beta * np.log(beta) / ((1 - beta) ** 2)\n    )\n    consump_func = (1 - beta) * w\n    return value_func, consump_func\n\n\nmodel2_V_true, model2_c_true = analytical_solution(model2.grid_w, model2)\n\n\nfigV, axV = plt.subplots(figsize=(8, 6))\naxV.set_title(\n    f\"Analytical versus numerical value function with {model2.ngridw = } and {model2.ngridc = } using Discretization method\"\n)\naxV.set_xlabel(\"Cake size, W\")\naxV.set_ylabel(\"Value function\")\n\naxV.plot(\n    model2.grid_w[1:],\n    model2_V[1:],\n    c=\"red\",\n    label=\"numerical VF\",\n)\naxV.plot(\n    model2.grid_w[1:],\n    model2_V_true[1:],\n    c=\"black\",\n    label=\"analytical VF\",\n)\naxV.legend()\nplt.ion()\nplt.show()\n\n\nfigC, axC = plt.subplots(figsize=(8, 6))\naxC.set_title(\n    f\"Analytical versus numerical policy function with {model2.ngridw = } and {model2.ngridc = } using Discretization method\"\n)\naxC.set_xlabel(\"Cake size, W\")\naxC.set_ylabel(\"Policy function\")\n\naxC.plot(\n    model2.grid_w[1:],\n    model2_c[1:],\n    c=\"red\",\n    label=\"numerical policy function\",\n)\naxC.plot(\n    model2.grid_w[1:],\n    model2_c_true[1:],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\naxC.legend()\nplt.ion()\nplt.show()\n\n\nFinal iteration: 205\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith the same size of wealth grid, the numerical solutions using the discretization method are more accurate than the on-the-gird method, with a cost of increasing computational time. You may think the discretization method is good enough. However, the truth is, the resulting consumption rule is still weird – it is not even monotone. And this is the most severe drawback of these discretization-based numerical solution – the numerical results may even not share the same monotonicity or concavity properties as the true, analytical solutions. In some economics applications, this could be detrimental for our analysis.\nTo see this point, we can zoom in, and check a specific region of the resulting policy function:\n\nfigC, axC = plt.subplots(figsize=(8, 6))\naxC.set_title(\n    f\"Analytical versus numerical policy function with {model2.ngridw = } and {model2.ngridc = } using Discretization method\"\n)\naxC.set_xlabel(\"Cake size, W\")\naxC.set_ylabel(\"Policy function\")\n\naxC.plot(\n    model2.grid_w[500:700],\n    model2_c[500:700],\n    c=\"red\",\n    label=\"numerical policy function\",\n)\naxC.plot(\n    model2.grid_w[500:700],\n    model2_c_true[500:700],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\naxC.legend()\nplt.ion()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02LifeCycle.html",
    "href": "02LifeCycle.html",
    "title": "2  Stochastic LifeCycle Consumption-Savings Model",
    "section": "",
    "text": "2.1 Model\nThe Bellman equation is as follows:\n\\[\\begin{equation}\nV(M)=\\max _{0 \\leq c \\leq M}\\{u(c)+\\beta \\mathbb{E}_{\\widetilde{R}, \\widetilde{y}} V(\\underbrace{\\widetilde{R}(M-c)+\\widetilde{y}}_{=M^{\\prime}})\\}\n\\end{equation}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Stochastic LifeCycle Consumption-Savings Model</span>"
    ]
  },
  {
    "objectID": "02LifeCycle.html#model",
    "href": "02LifeCycle.html#model",
    "title": "2  Stochastic LifeCycle Consumption-Savings Model",
    "section": "",
    "text": "Assume that \\(\\widetilde{R}\\) is fixed.\nStochastic income \\(\\widetilde{y}\\) follows a log normal distribution with \\(\\mu=\\) and \\(\\sigma\\) to be specified. Then we know that \\(\\widetilde{y} &gt; 0\\) and \\(\\mathbb{E}(\\widetilde{y}) = \\exp(\\sigma^2/2)\\).\nFor backward compatibility with the cake-eating example, we assume \\(\\widetilde{y}=0\\) as a special case.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Stochastic LifeCycle Consumption-Savings Model</span>"
    ]
  },
  {
    "objectID": "02LifeCycle.html#numerical-integration",
    "href": "02LifeCycle.html#numerical-integration",
    "title": "2  Stochastic LifeCycle Consumption-Savings Model",
    "section": "2.2 Numerical integration",
    "text": "2.2 Numerical integration\nThe key difficulty here is that we need to calculate the expectation (over different realizations of \\(\\widetilde{y}\\)) of the value function.\nTo do this, we use the Gauss-Legendre Quardrature method. Specifically, we need to select a set of discrete point of \\(\\widetilde{y}\\), along with the weights associated with each point. Then we approximate the integral by the weighted sums of value function evaluated at these \\(\\widetilde{y}\\).\nAgain, like in the cake-eating problem, we build up the next-period value function (before taking expectations) with states in axis=0, choices in axis=1.\nBut here, we need another dimension of array to store the quardrature points of \\(\\widetilde{y}\\). Notice that we put these quardrature points in axis=2, so that we can utilize a special feature of the np.dot() function.\nSee document here which says that\n\nIf a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.\n\nTo see this, we can have the following test:\n\n\nCode\nimport numpy as np \nimport matplotlib.pyplot as plt \n\na = np.zeros((3, 4, 2))\na[:,:,1] = np.ones((3,4))\nprint('a = ')\nprint(a)\nb = np.array([0.75, 0.25])\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(a, b) = ')\nprint(np.dot(a, b))\n\nprint()\nc = a.copy()\nc[:,0,:] = np.ones((3,2))\nprint('c = ')\nprint(c)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(c, b) = ')\nprint(np.dot(c, b))\n\nprint()\nd = a.copy()\nd[:,0,:] = np.ones((3,2))\nd[:,1,:] = np.zeros((3,2))\nprint('d = ')\nprint(d)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(d, b) = ')\nprint(np.dot(d, b))\n\nprint()\ne = a.copy()\ne[:,0,:] = np.ones((3,2))\ne[:,1,:] = np.zeros((3,2))\ne[0,:,:] = np.zeros((4,2))\nprint('e = ')\nprint(e)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(e, b) = ')\nprint(np.dot(e, b))\n\n\na = \n[[[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(a, b) = \n[[0.25 0.25 0.25 0.25]\n [0.25 0.25 0.25 0.25]\n [0.25 0.25 0.25 0.25]]\n\nc = \n[[[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(c, b) = \n[[1.   0.25 0.25 0.25]\n [1.   0.25 0.25 0.25]\n [1.   0.25 0.25 0.25]]\n\nd = \n[[[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(d, b) = \n[[1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]]\n\ne = \n[[[0. 0.]\n  [0. 0.]\n  [0. 0.]\n  [0. 0.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(e, b) = \n[[0.   0.   0.   0.  ]\n [1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Stochastic LifeCycle Consumption-Savings Model</span>"
    ]
  }
]