[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dynamic Programming Basics",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "02CakeEating.html",
    "href": "02CakeEating.html",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "",
    "text": "2 The Cake Eating Problem",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#problem-setup",
    "href": "02CakeEating.html#problem-setup",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "2.1 Problem setup",
    "text": "2.1 Problem setup\nSuppose that you are presented with a cake of size \\(W_0\\) at time \\(0\\). At each period of time \\(t = 0, 1, \\ldots\\), you can eat some of the cake but must save the rest. Let \\(c_t\\) be your consumption in period \\(t\\), and let \\(u(c_t)\\) represent the flow of utility from this consumption. Here, we use \\(u(c) = \\log(c)\\), which is real valued, differentiable, strictly increasing, and strictly concave, and \\(\\lim_{c \\rightarrow 0^+} u^\\prime(c) = +\\infty\\). Therefore, the problem is\n\\[\\begin{equation}\n    \\notag\n    \\begin{aligned}\n        \\max_{\\{c_t\\}_{t=0}^{\\infty}} & \\sum_{t=0}^{\\infty} \\beta^t u(c_t) \\\\\n        \\text{ s.t.   } & W_{t+1} = W_t - c_t, \\\\\n        & c_{t}\\geq 0,\\; W_{t+1} \\geq 0, \\; t = 0, 1, \\ldots.\n    \\end{aligned}\n\\end{equation}\\]\nThe Bellman equation associated with this problem is\n\\[\\begin{equation}\n    \\notag\n    V(W_t) = \\max_{0 \\leq c_t \\leq W_t} \\left\\{u(c_t) + \\beta V(\\underbrace{W_{t+1}}_{=W_t - c_t} )\\right\\}\n\\end{equation}\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#analytical-solution",
    "href": "02CakeEating.html#analytical-solution",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "2.2 Analytical solution",
    "text": "2.2 Analytical solution\nWe start with a guess that\n\\[\\begin{equation}\n    \\notag\n    V(W) = A + B \\log(W),\n\\end{equation}\\]\nwhere \\(A\\) and \\(B\\) are coefficients to be determined. Given this conjecture, we can write the Bellman equation as\n\\[\\begin{equation}\n    \\notag\n    A+B \\log (W)=\\max _c\\left\\{\\log c+\\beta \\left(A+B \\log (W-c) \\right)\\right\\}.\n\\end{equation}\\]\nThe FOC is\n\\[\\begin{equation}\n    \\notag\n    \\frac{1}{c}-\\frac{\\beta B}{W-c}=0 \\quad \\Rightarrow \\quad c=\\frac{W}{1+\\beta B},\\; W-c=\\frac{\\beta B W}{1+\\beta B}.\n\\end{equation}\\]\nThen we have\n\\[\\begin{equation}\n    \\notag\n    \\begin{aligned}\n    A+B \\log (W)= & \\log (W)+\\log \\frac{1}{1+\\beta B}+\\beta A+\\beta B \\log (W)+\\beta B \\log \\frac{\\beta B}{1+\\beta B} \\\\\n    \\Rightarrow & \\left\\{\\\n    \\begin{array}{ll}\n        & A=\\beta A+\\log \\frac{1}{1+\\beta B}+\\beta B \\log \\frac{\\beta B}{1+\\beta B} \\\\\n        & B=1+\\beta B\n    \\end{array}\\right.\n    \\end{aligned}\n\\end{equation}\\]ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}ed} \\end{equation}\nAfter some algebraic calculation, we can obtain the analytic solution to this simple cake-eating problem:\n\\[\\begin{equation}\n    \\notag\n    \\begin{aligned}\n    & c^{\\star}(W)=(1-\\beta) W \\\\\n    & V(W)=\\frac{\\log (W)}{1-\\beta}+\\frac{\\log (1-\\beta)}{1-\\beta}+\\frac{\\beta \\log (\\beta)}{(1-\\beta)^2}\n    \\end{aligned}\n\\end{equation}\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#value-function-iteration-interpolation-is-needed",
    "href": "02CakeEating.html#value-function-iteration-interpolation-is-needed",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "3.1 Value function iteration: Interpolation is needed",
    "text": "3.1 Value function iteration: Interpolation is needed\nValue function iteration means that we start with an arbitrary guess \\(V_0(W)\\). At iteration \\(i = 1, 2, \\ldots\\), we compute\n\\[\\begin{equation}\n    \\notag\n    \\begin{aligned}\n    V_i(W)=T\\left(V_{i-1}\\right)(W) & =\\max _{0 \\leq c \\leq W}\\left\\{u(c)+\\beta V_{i-1}(W-c)\\right\\} \\\\\n    c_{i-1}(W) & =\\underset{0 \\leq c \\leq W}{\\arg \\max }\\left\\{u(c)+\\beta V_{i-1}(W-c)\\right\\}\n    \\end{aligned}.\n\\end{equation}\\]\nTo put this idea into practice, we first need to {}, that is, to construct a grid of cake-sizes \\(\\overrightarrow{W} \\in \\mathcal{W} := \\{0, \\ldots, \\overline{W}\\}\\), and then calculate the following maximization problem in iteration \\(i\\):\n\\[\\begin{equation}\n    \\notag\n    V_i(\\overrightarrow{W})=\\max _{0 \\leq c \\leq \\overrightarrow{W}}\\left\\{u(c)+\\beta V_{i-1}(\\overrightarrow{W}-c)\\right\\}.\n\\end{equation}\\]\nHowever, one important complication is that we need to evaluate \\(V_{i-1}\\) {}, that is, there is no guarantee that \\(\\overrightarrow{W}-c \\in \\mathcal{W}\\). Therefore, we need to exploit some interpolation or function approximation techniques.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#avoiding-interpolation-solving-the-maximization-problem-on-the-grid",
    "href": "02CakeEating.html#avoiding-interpolation-solving-the-maximization-problem-on-the-grid",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "3.2 Avoiding interpolation: Solving the maximization problem “on-the-grid”",
    "text": "3.2 Avoiding interpolation: Solving the maximization problem “on-the-grid”\nWe can re-organize the Bellman equation as\n\\[\\begin{equation}\n    \\notag\n    V_i(\\overrightarrow{W})=\\max _{0 \\leq \\overrightarrow{W}^{\\prime} \\leq \\overrightarrow{W}}\\left\\{u\\left(\\overrightarrow{W}-\\overrightarrow{W}^{\\prime}\\right)+\\beta V_{i-1}\\left(\\overrightarrow{W}^{\\prime}\\right)\\right\\}.\n\\end{equation}\\]\nBy choosing \\(\\overrightarrow{W}, \\overrightarrow{W}^{\\prime} \\in \\mathcal{W}\\), the last-iteration value function \\(V_{i-1}\\) is always evaluated on the grid, thus avoiding interpolation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#python-codes",
    "href": "02CakeEating.html#python-codes",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "3.3 Python codes",
    "text": "3.3 Python codes\nFirst, let’s create a class that puts the cake eating problem into practice. The key method is CakeOnGrid.bellman, which takes a vector of \\(V_{i-1}\\) as input, and returns the updated (RHS of the Bellman equation) value function \\(V_i\\). Notice that how vectorization can be utilized to avoid writing loops.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nclass CakeOnGrid:\n    \"\"\"\n    This is a simple class to implement cake-eating problem using\n    endogenous grid method (EGM).\n    \"\"\"\n\n    def __init__(self, beta=0.9, W0=10, n_grid=50):\n        self.beta = beta\n        self.W0 = W0\n        self.n_grid = n_grid\n        self.c_min = 1e-10\n        self.W_grid = np.linspace(self.c_min, self.W0, n_grid)\n\n    def u(self, consumption):\n        return np.log(consumption)\n\n    def bellman(self, V0):\n        \"\"\"\n        Given value function at iteration i-1, this function returns the\n        value function at iteration i.\n\n        Input arguments:\n            V0 should be a 1-d np.ndarray object with size=self.n_grid.\n\n        Returned object:\n            V1 is a 1-d np.ndarray with size=self.n_grid.\n        \"\"\"\n        assert V0.size == self.n_grid\n\n        # W_array[i,:] == W_grid[i] , W_prime_array[:,j] == W_grid[j]\n        W_array, W_prime_array = np.meshgrid(\n            self.W_grid, self.W_grid, indexing=\"ij\"\n        )\n\n        # c_array[i,j] == W_grid[i]-W_grid[j]\n        # If W=W_grid[i], W_prime=W_grid[j], then c_array[i,j] is the\n        # corresponding consumption choice\n        c_array = W_array - W_prime_array\n        c_array[c_array &lt; 0] = np.nan\n        c_array[c_array == 0] = 1e-10\n        u_array = self.u(c_array)\n\n        # V0_array[i,j] == V0[j], for any i\n        _, V0_array = np.meshgrid(V0, V0, indexing=\"ij\")\n\n        # This is RHS of the Bellman equation (before optimization)\n        # V1_array[i,j] is the discounted value if W=W_grid[i],\n        #   and W_prime=W_grid[j]\n        V1_array = u_array + self.beta * V0_array\n\n        # V1[i] is the maximum among V1_array[i,:]\n        V1 = np.nanmax(V1_array, axis=1)\n\n        # c_index[i] is the column index where V1_array[i,:] achieves\n        # maximum\n        c_index = list(np.nanargmax(V1_array, axis=1))\n        c = c_array[list(range(V0.size)), c_index]\n\n        return V1, c\n\n    def solve(self, maxiter=1000, tol=1e-6, callback=None):\n        \"\"\"\n        This method solves the cake numerically.\n        \"\"\"\n        V0 = np.log(self.W_grid)\n        for iter in range(maxiter):\n            V1, c = self.bellman(V0)\n            if callback is not None:\n                callback(iter, self.W_grid, V1, c)\n            if np.all(abs(V1 - V0) &lt; tol):\n                break\n            V0 = V1\n        else:\n            raise RuntimeError(f\"Failed to converge in {maxiter} iterations.\")\n        return V1, c\n\nNext, let’s use a relatively “small” grid to present the convergence and to evaluate its accuracy compared with the analytical solution.\n\nVFI convergence:\n\n\nfrom cycler import cycler\n\ncake = CakeOnGrid(n_grid=50)\n\nplt.rcParams[\"axes.autolimit_mode\"] = \"round_numbers\"\nplt.rcParams[\"axes.xmargin\"] = 0\nplt.rcParams[\"axes.ymargin\"] = 0\nplt.rcParams[\"patch.force_edgecolor\"] = True\nplt.rcParams[\"axes.prop_cycle\"] = cycler(color=\"bgrcmyk\")\n\nfig1, ax1 = plt.subplots(figsize=(12, 8))\nplt.grid(which=\"both\", color=\"0.65\", linestyle=\"-\")\nax1.set_title(\"Value function convergence with VFI\")\nax1.set_xlabel(\"Cake size, W\")\nax1.set_ylabel(\"Value function\")\n\n\ndef plot_value_convergence(iter, grid, v, c):\n    \"\"\"Callback function for DP solver\"\"\"\n    if iter &lt; 5 or iter % 10 == 0:\n        ax1.plot(grid[1:], v[1:], label=f\"{iter=:3d}\", linewidth=1.5)\n\n\nV, c = cake.solve(callback=plot_value_convergence)\nplt.legend(loc=4)\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\n\nNumerical accuracy:\n\n\ndef analytical_V_func(w):\n    result = (\n        np.log(w) / (1 - cake.beta)\n        + np.log(1 - cake.beta) / (1 - cake.beta)\n        + cake.beta * np.log(cake.beta) / ((1 - cake.beta) ** 2)\n    )\n    return result\n\n\nanalytical_V = analytical_V_func(cake.W_grid)\nanalytical_c = (1 - cake.beta) * cake.W_grid\n\nfig2, ax2 = plt.subplots(figsize=(12, 8))\nax2.set_title(\n    f\"Analytical versus numerical value function with {cake.n_grid = }\"\n)\nax2.set_xlabel(\"Cake size, W\")\nax2.set_ylabel(\"Value function\")\n\nax2.plot(cake.W_grid[1:], V[1:], c=\"red\", label=\"numerical VF\")\nax2.plot(cake.W_grid[1:], analytical_V[1:], c=\"black\", label=\"analytical VF\")\nplt.legend()\nplt.ion()\nplt.show()\n\n\nfig3, ax3 = plt.subplots(figsize=(12, 8))\nax3.set_title(\n    f\"Analytical versus numerical policy function with {cake.n_grid = }\"\n)\nax3.set_xlabel(\"Cake size, W\")\nax3.set_ylabel(\"Policy function\")\n\nax3.plot(\n    cake.W_grid[1:], \n    c[1:], \n    c=\"red\", \n    label=\"numerical policy function\"\n)\nax3.plot(\n    cake.W_grid[1:],\n    analytical_c[1:],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\nplt.legend()\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice that this”on-grid” method implicitly implies that consumption can only take values that are difference between two points in the wealth grid, thus, we are also discretizing the consumption grid if we use this method.\nFinally, let’s use a finer grid with n_grid=500.\n\ncake500 = CakeOnGrid(n_grid=500)\n\nplt.rcParams[\"axes.autolimit_mode\"] = \"round_numbers\"\nplt.rcParams[\"axes.xmargin\"] = 0\nplt.rcParams[\"axes.ymargin\"] = 0\nplt.rcParams[\"patch.force_edgecolor\"] = True\nplt.rcParams[\"axes.prop_cycle\"] = cycler(color=\"bgrcmyk\")\n\nfig1, ax1 = plt.subplots(figsize=(12, 8))\nplt.grid(which=\"both\", color=\"0.65\", linestyle=\"-\")\nax1.set_title(\"Value function convergence with VFI\")\nax1.set_xlabel(\"Cake size, W\")\nax1.set_ylabel(\"Value function\")\n\n\ndef plot_value_convergence(iter, grid, v, c):\n    \"\"\"Callback function for DP solver\"\"\"\n    if iter &lt; 5 or iter % 10 == 0:\n        ax1.plot(grid[1:], v[1:], label=f\"{iter=:3d}\", linewidth=1.5)\n\n\nV, c = cake500.solve(callback=plot_value_convergence)\nplt.legend(loc=4)\nplt.ion()\nplt.show()\n\n\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n# -? subsection 1.2. compare with analytical solutions\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n\n\ndef analytical_V_func(w):\n    result = (\n        np.log(w) / (1 - cake500.beta)\n        + np.log(1 - cake500.beta) / (1 - cake500.beta)\n        + cake500.beta * np.log(cake500.beta) / ((1 - cake500.beta) ** 2)\n    )\n    return result\n\n\nanalytical_V = analytical_V_func(cake500.W_grid)\nanalytical_c = (1 - cake500.beta) * cake500.W_grid\n\nfig2, ax2 = plt.subplots(figsize=(12, 8))\nax2.set_title(\n    f\"Analytical versus numerical value function with {cake500.n_grid = }\"\n)\nax2.set_xlabel(\"Cake size, W\")\nax2.set_ylabel(\"Value function\")\n\nax2.plot(cake500.W_grid[1:], V[1:], c=\"red\", label=\"numerical VF\")\nax2.plot(cake500.W_grid[1:], analytical_V[1:], c=\"black\", label=\"analytical VF\")\nplt.legend()\nplt.ion()\nplt.show()\n\n\nfig3, ax3 = plt.subplots(figsize=(12, 8))\nax3.set_title(\n    f\"Analytical versus numerical policy function with {cake500.n_grid = }\"\n)\nax3.set_xlabel(\"Cake size, W\")\nax3.set_ylabel(\"Policy function\")\n\nax3.plot(\n    cake500.W_grid[1:], \n    c[1:], \n    c=\"red\", \n    label=\"numerical policy function\"\n)\nax3.plot(\n    cake500.W_grid[1:],\n    analytical_c[1:],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\nplt.legend()\nplt.ion()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#algorithm",
    "href": "02CakeEating.html#algorithm",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "4.1 Algorithm",
    "text": "4.1 Algorithm\nTo improve accuracy, we can go back to the original Bellman equation,\n\\[\\begin{equation}\n    \\notag\n    V(W_t) = \\max_{0 \\leq c_t \\leq W_t} \\left\\{u(c_t) + \\beta V(\\underbrace{W_{t+1}}_{=W_t - c_t} )\\right\\},\n\\end{equation}\\]\nand we treat \\(c_t\\) as our direct choice variable, instead of \\(W_{t+1}\\) like on-the-grid solution method.\nThere are two choices if we wish to discretize the \\(c\\) grid, given a value of the state variable \\(W\\). Either we can use a fixed \\(c\\) grid, regardless of the current state variable value, or we can use an adapted \\(c\\) grid, considering the construct the grid with bounds \\([0,W]\\), so that the \\(c\\) grid is actually a function of the value of the state variable. In the following python codes, this choice is controlled by the adapted_c_grid attribute.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#implementation",
    "href": "02CakeEating.html#implementation",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "4.2 Implementation",
    "text": "4.2 Implementation\n\nimport numpy as np\nfrom scipy import interpolate\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\n\nclass CakeDiscretDP:\n\n    def __init__(\n        self,\n        beta=0.9,\n        W0=10,\n        n_W_grid=50,\n        n_c_grid=100,\n        adapted_c_grid=True,\n    ):\n        self.beta = beta\n\n        # Initialize W grid:\n        # self.W_grid is a 1-d ndarray: size==self.n_W_grid.\n        # self.W_array_grid is a 2d ndarray: shape==(self.n_W_grid, 1).\n        self.W0 = W0\n        self.n_W_grid = n_W_grid\n        self.W_min = 1e-5\n        self.W_grid = np.linspace(self.W_min, self.W0, self.n_W_grid)\n        self.W_array_grid = self.W_grid[:, np.newaxis]\n\n        # Initialize the c grid as a 2-d ndarray with\n        # shape=(n_W_grid,n_c_grid).\n        self.c_min = 1e-10\n        self.n_c_grid = n_c_grid\n        self.adapted_c_grid = adapted_c_grid\n        # This step initialize the self.c_grid.\n        # If self.adapted_c_grid==True,\n        #   then this is a 2-d ndarray with\n        #   shape=(self.n_W_grid, self.n_c_grid) and interpretation:\n        #   self.adapted_c_grid[i,:] indicates a row vector collecting\n        #   the possible consumption when W=W_grid[i].\n        # If self.adapted_c_grid==False,\n        #   then this is a 2-d ndarray with\n        #   shape=(self.n_W_grid, self.n_c_grid) and interpretation:\n        #   self.adapted_c_grid[i,:] indicates a row vector collecting\n        #   a common consumption grid regardless of the value of the\n        #   state variable W.\n        if self.adapted_c_grid:\n            self.c_min = 1e-10\n            self.c_grid = np.zeros((self.n_W_grid, self.n_c_grid))\n            for w_index in range(self.n_W_grid):\n                self.c_grid[w_index, :] = np.linspace(\n                    self.c_min, self.W_grid[w_index], num=self.n_c_grid\n                )\n        else:\n            self.c_grid = np.linspace(\n                self.c_min, self.W0, num=self.n_c_grid\n            )\n            self.c_grid = np.tile(self.c_grid, (self.n_W_grid, 1))\n\n    def u(self, consumption):\n        return np.log(consumption)\n\n    def bellman(self, V0):\n        \"\"\"\n        Given value function at iteration i-1, this function returns the\n        value function at iteration i.\n\n        Input arguments:\n            V0 should be a 1-d np.ndarray object with size==self.n_W_grid.\n\n        Returned object:\n            V1 is a 1-d np.ndarray with size==self.n_W_grid.\n            c is a 1-d np.ndarray with size==self.n_W_grid.\n        \"\"\"\n\n        W_prime = self.W_array_grid - self.c_grid\n        W_prime[W_prime &lt;= 0] = np.nan\n\n        interp = interpolate.interp1d(\n            self.W_grid,\n            V0,\n            bounds_error=False,\n            fill_value=\"extrapolate\",\n        )\n        V1_array = self.u(self.c_grid) + self.beta * interp(W_prime)\n        # V1_array[self.W_array_grid&lt;self.c_grid] = -np.Inf\n\n        V1 = np.nanmax(V1_array, axis=1)\n        c_index = list(np.nanargmax(V1_array, axis=1))\n        c = self.c_grid[list(range(self.n_W_grid)), c_index].ravel()\n\n        return V1, c\n\n    def solve(self, maxiter=1000, tol=1e-6, callback=None):\n        \"\"\"\n        This method solves the cake numerically.\n        \"\"\"\n        V0 = np.log(self.W_grid)\n        for iter in range(maxiter):\n            V1, c = self.bellman(V0)\n            if callback is not None:\n                callback(iter, self.W_grid, V1, c)\n            if np.all(abs(V1 - V0) &lt; tol):\n                break\n            V0 = V1\n        else:\n            raise RuntimeError(\n                f\"Failed to converge in {maxiter} iterations.\"\n            )\n        return V1, c\n\nThe step that is likely to cause most problems is the dimension problem when I use broadcasting to vectorize the bellman equation iteration!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02CakeEating.html#test-the-solution",
    "href": "02CakeEating.html#test-the-solution",
    "title": "1  Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem",
    "section": "4.3 Test the solution",
    "text": "4.3 Test the solution\nFirst, I will choose n_W_grid=50, n_c_grid=100, and adapted_c_grid=False to see a worst-case scenario.\n\n\nCode\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n# -? subsection 2.1. 50, 100, False\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n# !! subsubsection 2.1.1. present convergence\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n\nplt.rcParams[\"axes.prop_cycle\"] = cycler(color=\"bgrcmyk\")\n\nfig1, (ax1, ax2) = plt.subplots(1, 2, figsize=(32, 8))\nplt.grid(which=\"both\", color=\"0.65\", linestyle=\"-\")\n\nax1.set_title(\"Value function convergence with VFI\")\nax1.set_xlabel(\"Cake size, W\")\nax1.set_ylabel(\"Value function\")\n\nax2.set_title(\"Policy function convergence with VFI\")\nax2.set_xlabel(\"Cake size, W\")\nax2.set_ylabel(\"Policy function\")\n\n\ndef plot_value_convergence(iter, grid, v, c):\n    \"\"\"Callback function for DP solver\"\"\"\n    if iter &lt; 5 or iter % 10 == 0:\n        ax1.plot(grid[1:], v[1:], label=f\"{iter=:3d}\", linewidth=1)\n        ax2.plot(grid[1:], c[1:], label=f\"{iter=:3d}\", linewidth=1)\n\n\ncake_50_100_F = CakeDiscretDP(adapted_c_grid=False)\n\nV_50_100_F, c_50_100_F = cake_50_100_F.solve(\n    callback=plot_value_convergence\n)\n\ndef analytical_V_func(w):\n    result = (\n        np.log(w) / (1 - cake_50_100_F.beta)\n        + np.log(1 - cake_50_100_F.beta) / (1 - cake_50_100_F.beta)\n        + cake_50_100_F.beta\n        * np.log(cake_50_100_F.beta)\n        / ((1 - cake_50_100_F.beta) ** 2)\n    )\n    return result\n\n\nanalytical_V = analytical_V_func(cake_50_100_F.W_grid)\nanalytical_c = (1 - cake_50_100_F.beta) * cake_50_100_F.W_grid\n\nax1.plot(\n    cake_50_100_F.W_grid[1:],\n    analytical_V[1:],\n    c=\"red\",\n    label=\"analytical VF\",\n    linewidth=2,\n    linestyle=\"dashed\",\n)\nax2.plot(\n    cake_50_100_F.W_grid[1:],\n    analytical_c[1:],\n    c=\"red\",\n    label=\"analytical policy\",\n    linewidth=2,\n    linestyle=\"dashed\",\n)\n\nax1.legend(bbox_to_anchor=(-0.34, 1), loc=\"upper left\")\nax2.legend(bbox_to_anchor=(1.34, 1), loc=\"upper right\")\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n# !! subsubsection 2.1.2. compare analytical with numerical answer\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n\nfigV, axV = plt.subplots(figsize=(12, 8))\naxV.set_title(\n    f\"Analytical versus numerical value function with {cake_50_100_F.n_W_grid = }, {cake_50_100_F.n_c_grid = }\"\n)\naxV.set_xlabel(\"Cake size, W\")\naxV.set_ylabel(\"Value function\")\n\naxV.plot(\n    cake_50_100_F.W_grid[1:],\n    V_50_100_F[1:],\n    c=\"red\",\n    label=\"numerical VF\",\n)\naxV.plot(\n    cake_50_100_F.W_grid[1:],\n    analytical_V[1:],\n    c=\"black\",\n    label=\"analytical VF\",\n)\naxV.legend()\nplt.ion()\nplt.show()\n\n\nfigC, axC = plt.subplots(figsize=(12, 8))\naxC.set_title(\n    f\"Analytical versus numerical policy function with {cake_50_100_F.n_W_grid = }, {cake_50_100_F.n_c_grid = }\"\n)\naxC.set_xlabel(\"Cake size, W\")\naxC.set_ylabel(\"Policy function\")\n\naxC.plot(\n    cake_50_100_F.W_grid[1:],\n    c_50_100_F[1:],\n    c=\"red\",\n    label=\"numerical policy function\",\n)\naxC.plot(\n    cake_50_100_F.W_grid[1:],\n    analytical_c[1:],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\naxC.legend()\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNext, using the same number of grid points, but now we use adapted \\(c\\) grid, which effectively increase the number of grid points since now all points in the grid are feasible.\n\n\nCode\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n# -? subsection 2.2. 50, 100, True\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n# !! subsubsection 2.2.1. present convergence\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n\nfig2, (ax1, ax2) = plt.subplots(1, 2, figsize=(32, 8))\nplt.grid(which=\"both\", color=\"0.65\", linestyle=\"-\")\n\nax1.set_title(\"Value function convergence with VFI\")\nax1.set_xlabel(\"Cake size, W\")\nax1.set_ylabel(\"Value function\")\n\nax2.set_title(\"Policy function convergence with VFI\")\nax2.set_xlabel(\"Cake size, W\")\nax2.set_ylabel(\"Policy function\")\n\n\ndef plot_value_convergence(iter, grid, v, c):\n    \"\"\"Callback function for DP solver\"\"\"\n    if iter &lt; 5 or iter % 10 == 0:\n        ax1.plot(grid[1:], v[1:], label=f\"{iter=:3d}\", linewidth=1)\n        ax2.plot(grid[1:], c[1:], label=f\"{iter=:3d}\", linewidth=1)\n\n\ncake_50_100_T = CakeDiscretDP(adapted_c_grid=True)\n\nV_50_100_T, c_50_100_T = cake_50_100_T.solve(\n    callback=plot_value_convergence\n)\n\n\ndef analytical_V_func(w):\n    result = (\n        np.log(w) / (1 - cake_50_100_T.beta)\n        + np.log(1 - cake_50_100_T.beta) / (1 - cake_50_100_T.beta)\n        + cake_50_100_T.beta\n        * np.log(cake_50_100_T.beta)\n        / ((1 - cake_50_100_T.beta) ** 2)\n    )\n    return result\n\n\nanalytical_V = analytical_V_func(cake_50_100_T.W_grid)\nanalytical_c = (1 - cake_50_100_T.beta) * cake_50_100_T.W_grid\n\nax1.plot(\n    cake_50_100_T.W_grid[1:],\n    analytical_V[1:],\n    c=\"red\",\n    label=\"analytical VF\",\n    linewidth=2,\n    linestyle=\"dashed\",\n)\nax2.plot(\n    cake_50_100_T.W_grid[1:],\n    analytical_c[1:],\n    c=\"red\",\n    label=\"analytical policy\",\n    linewidth=2,\n    linestyle=\"dashed\",\n)\n\nax1.legend(bbox_to_anchor=(-0.34, 1), loc=\"upper left\")\nax2.legend(bbox_to_anchor=(1.34, 1), loc=\"upper right\")\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n# !! subsubsection 2.2.2. compare analytical with numerical answer\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n\nfigV, axV = plt.subplots(figsize=(12, 8))\naxV.set_title(\n    f\"Analytical versus numerical value function with {cake_50_100_T.n_W_grid = }, {cake_50_100_T.n_c_grid = }\"\n)\naxV.set_xlabel(\"Cake size, W\")\naxV.set_ylabel(\"Value function\")\n\naxV.plot(\n    cake_50_100_T.W_grid[1:],\n    V_50_100_F[1:],\n    c=\"red\",\n    label=\"numerical VF\",\n)\naxV.plot(\n    cake_50_100_T.W_grid[1:],\n    analytical_V[1:],\n    c=\"black\",\n    label=\"analytical VF\",\n)\naxV.legend()\nplt.ion()\nplt.show()\n\n\nfigC, axC = plt.subplots(figsize=(12, 8))\naxC.set_title(\n    f\"Analytical versus numerical policy function with {cake_50_100_T.n_W_grid = }, {cake_50_100_T.n_c_grid = }\"\n)\naxC.set_xlabel(\"Cake size, W\")\naxC.set_ylabel(\"Policy function\")\n\naxC.plot(\n    cake_50_100_T.W_grid[1:],\n    c_50_100_F[1:],\n    c=\"red\",\n    label=\"numerical policy function\",\n)\naxC.plot(\n    cake_50_100_T.W_grid[1:],\n    analytical_c[1:],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\naxC.legend()\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, I will use finer grids, together with an adapted \\(c\\) grid:\n\n\nCode\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n# -? subsection 2.3. 500, 1000, True\n# -?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?#-?\n\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n# !! subsubsection 2.3.1. present convergence\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n\nfig3, (ax1, ax2) = plt.subplots(1, 2, figsize=(32, 8))\nplt.grid(which=\"both\", color=\"0.65\", linestyle=\"-\")\n\nax1.set_title(\"Value function convergence with VFI\")\nax1.set_xlabel(\"Cake size, W\")\nax1.set_ylabel(\"Value function\")\n\nax2.set_title(\"Policy function convergence with VFI\")\nax2.set_xlabel(\"Cake size, W\")\nax2.set_ylabel(\"Policy function\")\n\n\ndef plot_value_convergence(iter, grid, v, c):\n    \"\"\"Callback function for DP solver\"\"\"\n    if iter &lt; 5 or iter % 10 == 0:\n        ax1.plot(grid[1:], v[1:], label=f\"{iter=:3d}\", linewidth=1)\n        ax2.plot(grid[1:], c[1:], label=f\"{iter=:3d}\", linewidth=1)\n\n\ncake_500_1000_T = CakeDiscretDP(\n    n_W_grid=500, n_c_grid=1000, adapted_c_grid=True\n)\n\nV_500_1000_T, c_500_1000_T = cake_500_1000_T.solve(\n    callback=plot_value_convergence\n)\n\n\ndef analytical_V_func(w):\n    result = (\n        np.log(w) / (1 - cake_500_1000_T.beta)\n        + np.log(1 - cake_500_1000_T.beta) / (1 - cake_500_1000_T.beta)\n        + cake_500_1000_T.beta\n        * np.log(cake_500_1000_T.beta)\n        / ((1 - cake_500_1000_T.beta) ** 2)\n    )\n    return result\n\n\nanalytical_V = analytical_V_func(cake_500_1000_T.W_grid)\nanalytical_c = (1 - cake_500_1000_T.beta) * cake_500_1000_T.W_grid\n\nax1.plot(\n    cake_500_1000_T.W_grid[1:],\n    analytical_V[1:],\n    c=\"red\",\n    label=\"analytical VF\",\n    linewidth=2,\n    linestyle=\"dashed\",\n)\nax2.plot(\n    cake_500_1000_T.W_grid[1:],\n    analytical_c[1:],\n    c=\"red\",\n    label=\"analytical policy\",\n    linewidth=2,\n    linestyle=\"dashed\",\n)\n\nax1.legend(bbox_to_anchor=(-0.34, 1), loc=\"upper left\")\nax2.legend(bbox_to_anchor=(1.34, 1), loc=\"upper right\")\nplt.ion()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n# !! subsubsection 2.3.2. compare analytical with numerical answer\n# !!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!#!!\n\nfigV, axV = plt.subplots(figsize=(12, 8))\naxV.set_title(\n    f\"Analytical versus numerical value function with {cake_500_1000_T.n_W_grid = }, {cake_500_1000_T.n_c_grid = }\"\n)\naxV.set_xlabel(\"Cake size, W\")\naxV.set_ylabel(\"Value function\")\n\naxV.plot(\n    cake_500_1000_T.W_grid[1:],\n    V_500_1000_T[1:],\n    c=\"red\",\n    label=\"numerical VF\",\n)\naxV.plot(\n    cake_500_1000_T.W_grid[1:],\n    analytical_V[1:],\n    c=\"black\",\n    label=\"analytical VF\",\n)\naxV.legend()\nplt.ion()\nplt.show()\n\n\nfigC, axC = plt.subplots(figsize=(12, 8))\naxC.set_title(\n    f\"Analytical versus numerical policy function with {cake_500_1000_T.n_W_grid = }, {cake_500_1000_T.n_c_grid = }\"\n)\naxC.set_xlabel(\"Cake size, W\")\naxC.set_ylabel(\"Policy function\")\n\naxC.plot(\n    cake_500_1000_T.W_grid[1:],\n    c_500_1000_T[1:],\n    c=\"red\",\n    label=\"numerical policy function\",\n)\naxC.plot(\n    cake_500_1000_T.W_grid[1:],\n    analytical_c[1:],\n    c=\"black\",\n    label=\"analytical policy function\",\n)\naxC.legend()\nplt.ion()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course 30 and 32: Dynamic Programming 1 - Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "03LifeCycle.html",
    "href": "03LifeCycle.html",
    "title": "2  Course 35: Stochastic LifeCycle Consumption-Savings Model: Discretized Choice Variable",
    "section": "",
    "text": "3 Stochastic LifeCycle Consumption-Savings Model",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Course 35: Stochastic LifeCycle Consumption-Savings Model: Discretized Choice Variable</span>"
    ]
  },
  {
    "objectID": "03LifeCycle.html#model",
    "href": "03LifeCycle.html#model",
    "title": "2  Course 35: Stochastic LifeCycle Consumption-Savings Model: Discretized Choice Variable",
    "section": "3.1 Model",
    "text": "3.1 Model\nThe Bellman equation is as follows:\n\\[\\begin{equation}\nV(M)=\\max _{0 \\leq c \\leq M}\\{u(c)+\\beta \\mathbb{E}_{\\widetilde{R}, \\widetilde{y}} V(\\underbrace{\\widetilde{R}(M-c)+\\widetilde{y}}_{=M^{\\prime}})\\}\n\\end{equation}\\]\n\nAssume that \\(\\widetilde{R}\\) is fixed.\nStochastic income \\(\\widetilde{y}\\) follows a log normal distribution with \\(\\mu=\\) and \\(\\sigma\\) to be specified. Then we know that \\(\\widetilde{y} &gt; 0\\) and \\(\\mathbb{E}(\\widetilde{y}) = \\exp(\\sigma^2/2)\\).\nFor backward compatibility with the cake-eating example, we assume \\(\\widetilde{y}=0\\) as a special case.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Course 35: Stochastic LifeCycle Consumption-Savings Model: Discretized Choice Variable</span>"
    ]
  },
  {
    "objectID": "03LifeCycle.html#numerical-integration",
    "href": "03LifeCycle.html#numerical-integration",
    "title": "2  Course 35: Stochastic LifeCycle Consumption-Savings Model: Discretized Choice Variable",
    "section": "3.2 Numerical integration",
    "text": "3.2 Numerical integration\nThe key difficulty here is that we need to calculate the expectation (over different realizations of \\(\\widetilde{y}\\)) of the value function.\nTo do this, we use the Gauss-Legendre Quardrature method. Specifically, we need to select a set of discrete point of \\(\\widetilde{y}\\), along with the weights associated with each point. Then we approximate the integral by the weighted sums of value function evaluated at these \\(\\widetilde{y}\\).\nAgain, like in the cake-eating problem, we build up the next-period value function (before taking expectations) with states in axis=0, choices in axis=1.\nBut here, we need another dimension of array to store the quardrature points of \\(\\widetilde{y}\\). Notice that we put these quardrature points in axis=2, so that we can utilize a special feature of the np.dot() function.\nSee document here which says that\n\nIf a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.\n\nTo see this, we can have the following test:\n\n\nCode\nimport numpy as np \nimport matplotlib.pyplot as plt \n\na = np.zeros((3, 4, 2))\na[:,:,1] = np.ones((3,4))\nprint('a = ')\nprint(a)\nb = np.array([0.75, 0.25])\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(a, b) = ')\nprint(np.dot(a, b))\n\nprint()\nc = a.copy()\nc[:,0,:] = np.ones((3,2))\nprint('c = ')\nprint(c)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(c, b) = ')\nprint(np.dot(c, b))\n\nprint()\nd = a.copy()\nd[:,0,:] = np.ones((3,2))\nd[:,1,:] = np.zeros((3,2))\nprint('d = ')\nprint(d)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(d, b) = ')\nprint(np.dot(d, b))\n\nprint()\ne = a.copy()\ne[:,0,:] = np.ones((3,2))\ne[:,1,:] = np.zeros((3,2))\ne[0,:,:] = np.zeros((4,2))\nprint('e = ')\nprint(e)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(e, b) = ')\nprint(np.dot(e, b))\n\n\na = \n[[[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(a, b) = \n[[0.25 0.25 0.25 0.25]\n [0.25 0.25 0.25 0.25]\n [0.25 0.25 0.25 0.25]]\n\nc = \n[[[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(c, b) = \n[[1.   0.25 0.25 0.25]\n [1.   0.25 0.25 0.25]\n [1.   0.25 0.25 0.25]]\n\nd = \n[[[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(d, b) = \n[[1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]]\n\ne = \n[[[0. 0.]\n  [0. 0.]\n  [0. 0.]\n  [0. 0.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(e, b) = \n[[0.   0.   0.   0.  ]\n [1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Course 35: Stochastic LifeCycle Consumption-Savings Model: Discretized Choice Variable</span>"
    ]
  }
]