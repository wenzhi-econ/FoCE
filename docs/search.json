[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dynamic Programming Basics",
    "section": "",
    "text": "Preface\nThis website stores my notes on solving simply dynamic programming problems in economics using Python. Theses are based on the course Foundation of Computational Economics, ANU, 2021.\nThe notes focus on the following three points: 1. Create a proper Python object to represent an economics model. 2. Conduct unit tests when developing model methods to solve the model. 3. Use type hinting to track down the calculation process, and minimize potential errors in each step.\nThe notes do not necessarily present the best numerical methods and solution methods to deal with these models. It is more programming-oriented, aiming to improve my Python skills to solve, simulate, and estimate an economics model.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01CakeEating.html",
    "href": "01CakeEating.html",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "",
    "text": "1.1 Problem Setup\nSuppose that we are presented with a cake of size \\(W_0\\) at time \\(0\\). At each period of time \\(t = 0, 1, \\ldots\\), you can eat some of the cake but must save the rest. Let \\(c_t\\) be your consumption in period \\(t\\), and let \\(u(c_t)\\) represent the flow of utility from this consumption. Here, we use \\(u(c) = \\log(c)\\), which is real valued, differentiable, strictly increasing, and strictly concave, and \\(\\lim_{c \\rightarrow 0^+} u^\\prime(c) = +\\infty\\). Therefore, the problem is\n\\[\n\\begin{aligned}\n    \\max_{\\{c_t\\}_{t=0}^{\\infty}} & \\sum_{t=0}^{\\infty} \\beta^t u(c_t) \\\\\n    \\text{s.t.   } & W_{t+1} = W_t - c_t, \\\\\n    & c_{t}\\geq 0,\\; W_{t+1} \\geq 0, \\; t = 0, 1, \\ldots; \\\\\n    \\text{given  } & W_0 &gt; 0.\n\\end{aligned}\n\\]\nThe Bellman equation associated with this problem is\n\\[\nV(W_t) = \\max_{0 \\leq c_t \\leq W_t} \\left\\{u(c_t) + \\beta V(\\underbrace{W_{t+1}}_{=W_t - c_t} )\\right\\}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "01CakeEating.html#problem-setup",
    "href": "01CakeEating.html#problem-setup",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "",
    "text": "1.1.1 Analytical Solution\nWe start with a guess that\n\\[\nV(W) = A + B \\log(W),\n\\]\nwhere \\(A\\) and \\(B\\) are coefficients to be determined. Given this conjecture, we can write the Bellman equation as\n\\[\nA+B \\log (W)=\\max _c\\left\\{\\log c+\\beta \\left(A+B \\log (W-c) \\right)\\right\\}.\n\\]\nThe FOC is\n\\[\n\\frac{1}{c}-\\frac{\\beta B}{W-c}=0 \\quad \\Rightarrow \\quad c=\\frac{W}{1+\\beta B},\\; W-c=\\frac{\\beta B W}{1+\\beta B}.\n\\]\nThen we have \\[\n\\begin{aligned}\nA+B \\log (W)= & \\log (W)+\\log \\frac{1}{1+\\beta B}+\\beta A+\\beta B \\log (W)+\\beta B \\log \\frac{\\beta B}{1+\\beta B} \\\\\n\\Rightarrow & \\left\\{\\\n\\begin{array}{ll}\n    & A=\\beta A+\\log \\frac{1}{1+\\beta B}+\\beta B \\log \\frac{\\beta B}{1+\\beta B} \\\\\n    & B=1+\\beta B\n\\end{array}\\right.\n\\end{aligned}\n\\]\nAfter some algebraic calculation, we can obtain the analytic solution to this simple cake-eating problem:\n\\[\n\\begin{aligned}\n& c^{\\star}(W)=(1-\\beta) W \\\\\n& V(W)=\\frac{\\log (W)}{1-\\beta}+\\frac{\\log (1-\\beta)}{1-\\beta}+\\frac{\\beta \\log (\\beta)}{(1-\\beta)^2}\n\\end{aligned}\n\\]\n\n\n1.1.2 A Python Class to Represent the Problem\nFirst, there are two model parameters, \\(\\beta\\) and \\(W_0\\). However, these two economics parameters are not enough to represent this problem in a computer, we need other numerical parameters to solve the problem, which are all set to be optional arguments when initializing an instance.\nTwo things deserve some extra attention. type hinting is used (which is a soft requirement) for two model parameters, since we are very unlikely to pass wrong types to these arguments. However, I use strong assert function to check the passing numerical parameters, since this is more likely to be sources of mistakes.\n\nimport numpy as np\nfrom typing import Any\n\nclass CakeEating:\n    \"\"\"\n    This class solves the cake-eating problems using different numerical\n    methods.\n\n    Through this script, I hope to be more familiar with creating a\n    Python class to represent an economics model, and to be more\n    familiar with NumPy type hinting to track the calculation process,\n    and to perform unit tests when developing codes.\n    \"\"\"\n\n    def __init__(\n        self, beta: float = 0.9, w0: float = 100, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"\n        Initialize an object instance with model parameters, and\n        possibly numerical parameters.\n        \"\"\"\n        self.beta = beta\n        self.w0 = w0\n\n        if \"ngrid_w\" in kwargs:\n            assert isinstance(\n                kwargs[\"ngrid_w\"], int\n            ), \"ngrid_w should be an integer!\"\n            self.ngrid_w = kwargs[\"ngrid_w\"]\n        else:\n            self.ngrid_w = 100\n\n        if \"c_min\" in kwargs:\n            assert isinstance(kwargs[\"c_min\"], float)\n            self.c_min = kwargs[\"c_min\"]\n        else:\n            self.c_min = 1e-10\n\n        if \"tol\" in kwargs:\n            assert isinstance(kwargs[\"tol\"], float)\n            self.tol = kwargs[\"tol\"]\n        else:\n            self.tol = 1e-10\n\n    def __repr__(self) -&gt; str:\n        return f\"A simple cake-eating problem with beta = {self.beta:.2f} and initial wealth W_0 = {self.w0:.3f}.\\nOther numerical parameters are set to {self.ngrid_w = }, {self.c_min = }, {self.tol = }.\"\n\n\n\n1.1.3 Unit Tests\nHow can we make sure that our class works just as our expectation, even though only the constructor has been coded up? One important approach is to perform unit tests, which specifically test this unit of codes.\nIn principle, we can manually check if our constructor gets the same results as our expectations. For example,\n\n\nCode\nmodel1 = CakeEating()\nprint(model1)\nmodel1.beta\nmodel1.w0\nmodel1.ngrid_w\nmodel1.c_min\nmodel1.tol\n\nmodel4 = CakeEating(beta = 0.66, ngrid_w=1000, c_min=1e-5)\nmodel4.beta\nmodel4.w0\nmodel4.ngrid_w\nmodel4.c_min\nmodel4.tol\n\n# model_wrongNtype = CakeEating(ngrid_w=10.0) \n#     AssertionError: ngrid_w should be an integer!\n\n\nExecuting the final line will throw out an error message, which is exactly what we want – a strict type checking for numerical parameters. However, a better way to perform these tests is using certain testing framework, which can greatly reduce our burden.\n\n\ntest_CakeEating.py\n\n# | eval: false\n\n1import CakeEating as CE\n\nimport pytest\n\ndef test_init_model_pars():\n    model1 = CE.CakeEating()\n    assert model1.beta == 0.90\n2    assert model1.w0 == pytest.approx(100.0)\n\n    model2 = CE.CakeEating(beta=0.66)\n    assert model2.beta == pytest.approx(0.66)\n\n\ndef test_init_numerical_types():\n3    model3 = CE.CakeEating(ngrid_w=99.0)\n    assert model3.ngrid_w == 99\n\n# def test_init_numerical_types_elegant():\n4#     with pytest.raises(AssertionError):\n#         model3 = CE.CakeEating(ngrid_w=99.0)\n#         assert model3.ngrid_w == 99\n\ndef test_init_numerical_pars():\n    model3 = CE.CakeEating(ngrid_w=1000, tol=1e-9)\n    assert model3.ngrid_w == 1000\n    assert model3.c_min == 1e-10\n    assert model3.tol == 1e-9\n\n5pytest.main()\n\n\n1\n\nIf we are separating the model script and the test script into two files, then an extra importation step is needed.\n\n2\n\npytest.approx() is used to compare two floats.\n\n3\n\nWe are expecting an error message will be thrown out.\n\n4\n\nIf we run this alternative test with exception capturing, then we will actually pass the test.\n\n5\n\nRight now, we cannot run this in IPython. Therefore, after saving this file, we need to run the following command in the command line: pytest \"test_CakeEating.py\" to show the results.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "01CakeEating.html#on-the-grid-solution-method-discretize-only-w",
    "href": "01CakeEating.html#on-the-grid-solution-method-discretize-only-w",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "1.2 On-the-Grid Solution Method: Discretize only \\(W\\)",
    "text": "1.2 On-the-Grid Solution Method: Discretize only \\(W\\)\n\n1.2.1 Value Function Iteration: Interpolation is Necessary\nValue function iteration means that we start with an arbitrary guess \\(V_0(W)\\). At iteration \\(i = 1, 2, \\ldots\\), we compute\n\\[\n\\begin{aligned}\nV_i(W)=T\\left(V_{i-1}\\right)(W) & =\\max _{0 \\leq c \\leq W}\\left\\{u(c)+\\beta V_{i-1}(W-c)\\right\\} \\\\\nc_{i-1}(W) & =\\underset{0 \\leq c \\leq W}{\\arg \\max }\\left\\{u(c)+\\beta V_{i-1}(W-c)\\right\\}\n\\end{aligned}.\n\\]\nTo put this idea into practice, we first need dto construct a grid of cake-sizes \\(\\overrightarrow{W} \\in \\mathcal{W} := \\{0, \\ldots, \\overline{W}\\}\\), and then calculate the following maximization problem in iteration \\(i\\):\n\\[\nV_i(\\overrightarrow{W})=\\max _{0 \\leq c \\leq \\overrightarrow{W}}\\left\\{u(c)+\\beta V_{i-1}(\\overrightarrow{W}-c)\\right\\}.\n\\]\nHowever, one important complication is that we need to evaluate \\(V_{i-1}\\) {}, that is, there is no guarantee that \\(\\overrightarrow{W}-c \\in \\mathcal{W}\\). Therefore, we need to exploit some interpolation or function approximation techniques.\n\n\n1.2.2 Assume \\(c\\) Can ONLY Take Gaps between Gridpoints as Values\nWe can re-organize the Bellman equation as\n\\[\nV_i(\\overrightarrow{W})=\\max _{0 \\leq \\overrightarrow{W}^{\\prime} \\leq \\overrightarrow{W}}\\left\\{u\\left(\\overrightarrow{W}-\\overrightarrow{W}^{\\prime}\\right)+\\beta V_{i-1}\\left(\\overrightarrow{W}^{\\prime}\\right)\\right\\}.\n\\]\nBy choosing \\(\\overrightarrow{W}, \\overrightarrow{W}^{\\prime} \\in \\mathcal{W}\\), the last-iteration value function \\(V_{i-1}\\) is always evaluated on the grid, thus avoiding interpolation.\n\n\n1.2.3 Coding up the On-the-Grid Solution",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "01CakeEating.html#discretization-solution-method-discretize-both-w-and-c",
    "href": "01CakeEating.html#discretization-solution-method-discretize-both-w-and-c",
    "title": "1  Part I: The Cake Eating Problem",
    "section": "1.3 Discretization Solution Method: Discretize both \\(W\\) and \\(c\\)",
    "text": "1.3 Discretization Solution Method: Discretize both \\(W\\) and \\(c\\)\n\n1.3.1 Algorithm: Interpolation + Discretized \\(c\\)\nTo improve accuracy, we can go back to the original Bellman equation,\n\\[        \nV(W_t) = \\max_{0 \\leq c_t \\leq W_t} \\left\\{u(c_t) + \\beta V(\\underbrace{W_{t+1}}_{=W_t - c_t} )\\right\\},\n\\]\nand we treat \\(c_t\\) as our direct choice variable.\nThere are two choices if we wish to discretize the \\(c\\) grid, given a value of the state variable \\(W\\). Either we can use a fixed \\(c\\) grid, regardless of the current state variable value, or we can use an adapted \\(c\\) grid, considering the construct the grid with bounds \\([0,W]\\), so that the \\(c\\) grid is actually a function of the value of the state variable. In the following python codes, this choice is controlled by the adapted_c_grid attribute.\nAgain, there is no guarantee that \\(W_t - c_t\\) lies on the grid \\(\\overrightarrow{W}\\). To address this problem, we use a simple interpolation function scipy.interpolate.interp1d. I won’t take the credibility of the interpolation method seriously in this note, as the main focus is to develop good-quality and reader-friendly Python codes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I: The Cake Eating Problem</span>"
    ]
  },
  {
    "objectID": "02LifeCycle.html",
    "href": "02LifeCycle.html",
    "title": "2  Stochastic LifeCycle Consumption-Savings Model",
    "section": "",
    "text": "2.1 Model\nThe Bellman equation is as follows:\n\\[\\begin{equation}\nV(M)=\\max _{0 \\leq c \\leq M}\\{u(c)+\\beta \\mathbb{E}_{\\widetilde{R}, \\widetilde{y}} V(\\underbrace{\\widetilde{R}(M-c)+\\widetilde{y}}_{=M^{\\prime}})\\}\n\\end{equation}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Stochastic LifeCycle Consumption-Savings Model</span>"
    ]
  },
  {
    "objectID": "02LifeCycle.html#model",
    "href": "02LifeCycle.html#model",
    "title": "2  Stochastic LifeCycle Consumption-Savings Model",
    "section": "",
    "text": "Assume that \\(\\widetilde{R}\\) is fixed.\nStochastic income \\(\\widetilde{y}\\) follows a log normal distribution with \\(\\mu=\\) and \\(\\sigma\\) to be specified. Then we know that \\(\\widetilde{y} &gt; 0\\) and \\(\\mathbb{E}(\\widetilde{y}) = \\exp(\\sigma^2/2)\\).\nFor backward compatibility with the cake-eating example, we assume \\(\\widetilde{y}=0\\) as a special case.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Stochastic LifeCycle Consumption-Savings Model</span>"
    ]
  },
  {
    "objectID": "02LifeCycle.html#numerical-integration",
    "href": "02LifeCycle.html#numerical-integration",
    "title": "2  Stochastic LifeCycle Consumption-Savings Model",
    "section": "2.2 Numerical integration",
    "text": "2.2 Numerical integration\nThe key difficulty here is that we need to calculate the expectation (over different realizations of \\(\\widetilde{y}\\)) of the value function.\nTo do this, we use the Gauss-Legendre Quardrature method. Specifically, we need to select a set of discrete point of \\(\\widetilde{y}\\), along with the weights associated with each point. Then we approximate the integral by the weighted sums of value function evaluated at these \\(\\widetilde{y}\\).\nAgain, like in the cake-eating problem, we build up the next-period value function (before taking expectations) with states in axis=0, choices in axis=1.\nBut here, we need another dimension of array to store the quardrature points of \\(\\widetilde{y}\\). Notice that we put these quardrature points in axis=2, so that we can utilize a special feature of the np.dot() function.\nSee document here which says that\n\nIf a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.\n\nTo see this, we can have the following test:\n\n\nCode\nimport numpy as np \nimport matplotlib.pyplot as plt \n\na = np.zeros((3, 4, 2))\na[:,:,1] = np.ones((3,4))\nprint('a = ')\nprint(a)\nb = np.array([0.75, 0.25])\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(a, b) = ')\nprint(np.dot(a, b))\n\nprint()\nc = a.copy()\nc[:,0,:] = np.ones((3,2))\nprint('c = ')\nprint(c)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(c, b) = ')\nprint(np.dot(c, b))\n\nprint()\nd = a.copy()\nd[:,0,:] = np.ones((3,2))\nd[:,1,:] = np.zeros((3,2))\nprint('d = ')\nprint(d)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(d, b) = ')\nprint(np.dot(d, b))\n\nprint()\ne = a.copy()\ne[:,0,:] = np.ones((3,2))\ne[:,1,:] = np.zeros((3,2))\ne[0,:,:] = np.zeros((4,2))\nprint('e = ')\nprint(e)\nprint(f'\\nb = ')\nprint(b)\nprint(f'\\nnp.dot(e, b) = ')\nprint(np.dot(e, b))\n\n\na = \n[[[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[0. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(a, b) = \n[[0.25 0.25 0.25 0.25]\n [0.25 0.25 0.25 0.25]\n [0.25 0.25 0.25 0.25]]\n\nc = \n[[[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 1.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(c, b) = \n[[1.   0.25 0.25 0.25]\n [1.   0.25 0.25 0.25]\n [1.   0.25 0.25 0.25]]\n\nd = \n[[[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(d, b) = \n[[1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]]\n\ne = \n[[[0. 0.]\n  [0. 0.]\n  [0. 0.]\n  [0. 0.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]\n\n [[1. 1.]\n  [0. 0.]\n  [0. 1.]\n  [0. 1.]]]\n\nb = \n[0.75 0.25]\n\nnp.dot(e, b) = \n[[0.   0.   0.   0.  ]\n [1.   0.   0.25 0.25]\n [1.   0.   0.25 0.25]]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Stochastic LifeCycle Consumption-Savings Model</span>"
    ]
  }
]